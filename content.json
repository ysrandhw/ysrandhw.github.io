{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://ysrandhw.github.io","root":"/"},"pages":[],"posts":[{"title":"vue-webpack4.0","slug":"vue-webpack4.0","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2021/11/30/vue-webpack4.0/","link":"","permalink":"https://ysrandhw.github.io/2021/11/30/vue-webpack4.0/","excerpt":"","text":"开篇 原文地址：www.ccode.live/lentoo/list… 项目代码：github.com/lentoo/vue-… 前段时间，看到群里一些小伙伴面试的时候被面试官问到这类题目。平时大家开发vue项目的时候，相信大部分人都是使用 vue-cli脚手架生成的项目架构，然后 npm run install 安装依赖，npm run serve启动项目然后就开始写业务代码了。 但是对项目里的webpack封装和配置了解的不清楚，容易导致出问题不知如何解决，或者不会通过webpack去扩展新功能。 该篇文章主要是想告诉小伙伴们，如何一步一步的通过 webpack4来搭建自己的vue开发环境 首先我们要知道 vue-cli生成的项目，帮我们配置好了哪些功能？ ES6代码转换成ES5代码 scss/sass/less/stylus转css .vue文件转换成js文件 使用 jpg、png，font等资源文件 自动添加css各浏览器产商的前缀 代码热更新 资源预加载 每次构建代码清除之前生成的代码 定义环境变量 区分开发环境打包跟生产环境打包 …. 1. 搭建 webpack 基本环境该篇文章并不会细讲 webpack 是什么东西，如果还不是很清楚的话，可以先去看看 webpack官网 简单的说，webpack是一个模块打包机，可以分析你的项目依赖的模块以及一些浏览器不能直接运行的语言jsx、vue等转换成 js、css文件等，供浏览器使用。 1.1 初始化项目在命令行中执行 npm init 然后一路回车就行了，主要是生成一些项目基本信息。最后会生成一个 package.json 文件 12npm init复制代码 1.2 安装webpack 1.3 写点小代码测试一下webpack是否安装成功了新建一个src文件夹，然后再建一个main.js文件 123// src/main.jsconsole.log(&#x27;hello webpack&#x27;)复制代码 然后在 package.json 下面加一个脚本命令 然后运行该命令 12npm run serve复制代码 如果在 dist 目录下生成了一个main.js文件，则表示webpack工作正常 2. 开始配置功能 新建一个 build 文件夹，用来存放 webpack配置相关的文件 在build文件夹下新建一个webpack.config.js，配置webpack的基本配置 修改 webpack.config.js配置 修改package.json 文件，将之前添加的 serve 修改为 12&quot;serve&quot;: &quot;webpack ./src/main.js --config ./build/webpack.config.js&quot;复制代码 2.1 配置 ES6/7/8 转 ES5代码 安装相关依赖 12npm install babel-loader @babel/core @babel/preset-env复制代码 修改webpack.config.js配置 在项目根目录添加一个 babel.config.js 文件 然后执行 npm run serve 命令，可以看到 ES6代码被转成了ES5代码了 2.1.1 ES6/7/8 Api 转es5babel-loader只会将 ES6/7/8语法转换为ES5语法，但是对新api并不会转换。 我们可以通过 babel-polyfill 对一些不支持新语法的客户端提供新语法的实现 安装 12npm install @babel/polyfill复制代码 修改webpack.config.js配置 在 entry 中添加 @babel-polyfill 2.1.2 按需引入polyfill2.1.2 和 2.1.1 只需要配置一个就行 修改时间 2019-05-05、 来自评论区 兮漫天 的提醒 安装相关依赖 12npm install core-js@2 @babel/runtime-corejs2 -S复制代码 修改 babel-config.js 配置了按需引入 polyfill 后，用到es6以上的函数，babel会自动导入相关的polyfill，这样能大大减少 打包编译后的体积 2.2 配置 scss 转 css在没配置 css 相关的 loader 时，引入scss、css相关文件打包的话，会报错 安装相关依赖 12npm install sass-loader dart-sass css-loader style-loader -D复制代码 sass-loader, dart-sass主要是将 scss/sass 语法转为css css-loader主要是解析 css 文件 style-loader 主要是将 css 解析到 html页面 的 style 上 修改webpack.config.js配置 2.3 配置 postcss 实现自动添加css3前缀 安装相关依赖 12npm install postcss-loader autoprefixer -D复制代码 修改webpack.config.js配置 在项目根目录下新建一个 postcss.config.js 2.3 使用 html-webpack-plugin来创建html页面使用 html-webpack-plugin来创建html页面，并自动引入打包生成的js文件 安装依赖 12npm install html-webpack-plugin -D复制代码 新建一个 public/index.html 页面 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;复制代码 修改 1webpack-config.js 配置 2.4 配置 devServer 热更新功能通过代码的热更新功能，我们可以实现不刷新页面的情况下，更新我们的页面 安装依赖 12npm install webpack-dev-server -D复制代码 修改webpack.config.js配置 通过配置 devServer 和 HotModuleReplacementPlugin 插件来实现热更新 2.5 配置 webpack 打包 图片、媒体、字体等文件 安装依赖 12npm install file-loader url-loader -D复制代码 file-loader 解析文件url，并将文件复制到输出的目录中 url-loader 功能与 file-loader 类似，如果文件小于限制的大小。则会返回 base64 编码，否则使用 file-loader 将文件复制到输出的目录中 修改 webpack-config.js 配置 添加 rules 配置，分别对 图片，媒体，字体文件进行配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// build/webpack.config.jsconst path = require(&#x27;path&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const webpack = require(&#x27;webpack&#x27;)module.exports = &#123; // 省略其它配置 ... module: &#123; rules: [ // ... &#123; test: /\\.(jpe?g|png|gif)$/i, use: [ &#123; loader: &#x27;url-loader&#x27;, options: &#123; limit: 4096, fallback: &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;img/[name].[hash:8].[ext]&#x27; &#125; &#125; &#125; &#125; ] &#125;, &#123; test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/, use: [ &#123; loader: &#x27;url-loader&#x27;, options: &#123; limit: 4096, fallback: &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;media/[name].[hash:8].[ext]&#x27; &#125; &#125; &#125; &#125; ] &#125;, &#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/i, use: [ &#123; loader: &#x27;url-loader&#x27;, options: &#123; limit: 4096, fallback: &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;fonts/[name].[hash:8].[ext]&#x27; &#125; &#125; &#125; &#125; ] &#125;, ] &#125;, plugins: [ // ... ]&#125;复制代码 3. 让 webpack 识别 .vue 文件 安装需要的依赖文件 123npm install vue-loader vue-template-compiler cache-loader thread-loader -Dnpm install vue -S复制代码 vue-loader 用于解析.vue文件 vue-template-compiler 用于编译模板 cache-loader 用于缓存loader编译的结果 thread-loader 使用 worker 池来运行loader，每个 worker 都是一个 node.js 进程。 修改 webpack.config.js配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// build/webpack.config.jsconst path = require(&#x27;path&#x27;)const webpack = require(&#x27;webpack&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;)module.exports = &#123; // 指定打包模式 mode: &#x27;development&#x27;, entry: &#123; // ... &#125;, output: &#123; // ... &#125;, devServer: &#123; // ... &#125;, resolve: &#123; alias: &#123; vue$: &#x27;vue/dist/vue.runtime.esm.js&#x27; &#125;, &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/, use: [ &#123; loader: &#x27;cache-loader&#x27; &#125;, &#123; loader: &#x27;thread-loader&#x27; &#125;, &#123; loader: &#x27;vue-loader&#x27;, options: &#123; compilerOptions: &#123; preserveWhitespace: false &#125;, &#125; &#125; ] &#125;, &#123; test: /\\.jsx?$/, use: [ &#123; loader: &#x27;cache-loader&#x27; &#125;, &#123; loader: &#x27;thread-loader&#x27; &#125;, &#123; loader: &#x27;babel-loader&#x27; &#125; ] &#125;, // ... ] &#125;, plugins: [ // ... new VueLoaderPlugin() ]&#125;复制代码 测试一下 在 src 新建一个 App.vue 1234567891011121314151617181920212223// src/App.vue&lt;template&gt; &lt;div class=&quot;App&quot;&gt; Hello World &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, data() &#123; return &#123;&#125;; &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.App &#123; color: skyblue;&#125;&lt;/style&gt;复制代码 修改 main.js 1234567import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;new Vue(&#123; render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;)复制代码 运行一下 1npm run serve 4. 定义环境变量通过 webpack提供的DefinePlugin插件，可以很方便的定义环境变量 12345678plugins: [ new webpack.DefinePlugin(&#123; &#x27;process.env&#x27;: &#123; VUE_APP_BASE_URL: JSON.stringify(&#x27;http://localhost:3000&#x27;) &#125; &#125;),]复制代码 5. 区分生产环境和开发环境新建两个文件 webpack.dev.js 开发环境使用 webpack.prod.js 生产环境使用 webpack.config.js 公用配置 开发环境与生产环境的不同 5.1 开发环境 不需要压缩代码 需要热更新 css不需要提取到css文件 sourceMap … 5.2 生产环境 压缩代码 不需要热更新 提取css，压缩css文件 sourceMap 构建前清除上一次构建的内容 … 安装所需依赖 12npm i @intervolga/optimize-cssnano-plugin mini-css-extract-plugin clean-webpack-plugin webpack-merge copy-webpack-plugin -D复制代码 @intervolga/optimize-cssnano-plugin 用于压缩css代码 mini-css-extract-plugin 用于提取css到文件中 clean-webpack-plugin 用于删除上次构建的文件 webpack-merge 合并 webpack配置 copy-webpack-plugin 用户拷贝静态资源 5.3 开发环境配置 build/webpack.dev.js 12345678910111213141516171819202122232425262728293031323334353637383940414243// build/webpack.dev.jsconst merge = require(&#x27;webpack-merge&#x27;)const webpackConfig = require(&#x27;./webpack.config&#x27;)const webpack = require(&#x27;webpack&#x27;)module.exports = merge(webpackConfig, &#123; mode: &#x27;development&#x27;, devtool: &#x27;cheap-module-eval-source-map&#x27;, module: &#123; rules: [ &#123; test: /\\.(scss|sass)$/, use: [ &#123; loader: &#x27;style-loader&#x27; &#125;, &#123; loader: &#x27;css-loader&#x27;, options: &#123; importLoaders: 2 &#125; &#125;, &#123; loader: &#x27;sass-loader&#x27;, options: &#123; implementation: require(&#x27;dart-sass&#x27;) &#125; &#125;, &#123; loader: &#x27;postcss-loader&#x27; &#125; ] &#125;, ] &#125;, plugins: [ new webpack.DefinePlugin(&#123; &#x27;process.env&#x27;: &#123; NODE_ENV: JSON.stringify(&#x27;development&#x27;) &#125; &#125;), ]&#125;)复制代码 webpack.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// build/webpack.config.jsconst path = require(&#x27;path&#x27;)const webpack = require(&#x27;webpack&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;)module.exports = &#123; entry: &#123; // 配置入口文件 main: path.resolve(__dirname, &#x27;../src/main.js&#x27;) &#125;, output: &#123; // 配置打包文件输出的目录 path: path.resolve(__dirname, &#x27;../dist&#x27;), // 生成的 js 文件名称 filename: &#x27;js/[name].[hash:8].js&#x27;, // 生成的 chunk 名称 chunkFilename: &#x27;js/[name].[hash:8].js&#x27;, // 资源引用的路径 publicPath: &#x27;/&#x27; &#125;, devServer: &#123; hot: true, port: 3000, contentBase: &#x27;./dist&#x27; &#125;, resolve: &#123; alias: &#123; vue$: &#x27;vue/dist/vue.runtime.esm.js&#x27; &#125;, extensions: [ &#x27;.js&#x27;, &#x27;.vue&#x27; ] &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/, use: [ &#123; loader: &#x27;cache-loader&#x27; &#125;, &#123; loader: &#x27;vue-loader&#x27;, options: &#123; compilerOptions: &#123; preserveWhitespace: false &#125;, &#125; &#125; ] &#125;, &#123; test: /\\.jsx?$/, loader: &#x27;babel-loader&#x27; &#125;, &#123; test: /\\.(jpe?g|png|gif)$/, use: [ &#123; loader: &#x27;url-loader&#x27;, options: &#123; limit: 4096, fallback: &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;img/[name].[hash:8].[ext]&#x27; &#125; &#125; &#125; &#125; ] &#125;, &#123; test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/, use: [ &#123; loader: &#x27;url-loader&#x27;, options: &#123; limit: 4096, fallback: &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;media/[name].[hash:8].[ext]&#x27; &#125; &#125; &#125; &#125; ] &#125;, &#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/i, use: [ &#123; loader: &#x27;url-loader&#x27;, options: &#123; limit: 4096, fallback: &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;fonts/[name].[hash:8].[ext]&#x27; &#125; &#125; &#125; &#125; ] &#125;, ] &#125;, plugins: [ new VueLoaderPlugin(), new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname, &#x27;../public/index.html&#x27;) &#125;), new webpack.NamedModulesPlugin(), new webpack.HotModuleReplacementPlugin(), ]&#125;复制代码 5.4 生产环境配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192const path = require(&#x27;path&#x27;)const merge = require(&#x27;webpack-merge&#x27;)const webpack = require(&#x27;webpack&#x27;)const webpackConfig = require(&#x27;./webpack.config&#x27;)const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)const OptimizeCssnanoPlugin = require(&#x27;@intervolga/optimize-cssnano-plugin&#x27;);/* clean-webpack-plugin 3.0 以上的版本需要使用对象结构 */// const CleanWebpackPlugin = require(&#x27;clean-webpack-plugin&#x27;)const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;)const CopyWebpackPlugin = require(&#x27;copy-webpack-plugin&#x27;)module.exports = merge(webpackConfig, &#123; mode: &#x27;production&#x27;, devtool: &#x27;#source-map&#x27;, optimization: &#123; splitChunks: &#123; cacheGroups: &#123; vendors: &#123; name: &#x27;chunk-vendors&#x27;, test: /[\\\\\\/]node_modules[\\\\\\/]/, priority: -10, chunks: &#x27;initial&#x27; &#125;, common: &#123; name: &#x27;chunk-common&#x27;, minChunks: 2, priority: -20, chunks: &#x27;initial&#x27;, reuseExistingChunk: true &#125; &#125; &#125; &#125;, module: &#123; rules: [ &#123; test: /\\.(scss|sass)$/, use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, &#123; loader: &#x27;css-loader&#x27;, options: &#123; importLoaders: 2 &#125; &#125;, &#123; loader: &#x27;sass-loader&#x27;, options: &#123; implementation: require(&#x27;dart-sass&#x27;) &#125; &#125;, &#123; loader: &#x27;postcss-loader&#x27; &#125; ] &#125;, ] &#125;, plugins: [ new webpack.DefinePlugin(&#123; &#x27;process.env&#x27;: &#123; NODE_ENV: &#x27;production&#x27; &#125; &#125;), new MiniCssExtractPlugin(&#123; filename: &#x27;css/[name].[contenthash:8].css&#x27;, chunkFilename: &#x27;css/[name].[contenthash:8].css&#x27; &#125;), new OptimizeCssnanoPlugin(&#123; sourceMap: true, cssnanoOptions: &#123; preset: [ &#x27;default&#x27;, &#123; mergeLonghand: false, cssDeclarationSorter: false &#125; ] &#125; &#125;), new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, &#x27;../public&#x27;), to: path.resolve(__dirname, &#x27;../dist&#x27;) &#125; ]), new CleanWebpackPlugin() ]&#125;)复制代码 5.5 修改package.json12345&quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;webpack-dev-server --config ./build/webpack.dev.js&quot;, &quot;build&quot;: &quot;webpack --config ./build/webpack.prod.js&quot;&#125;,复制代码 6 打包分析有的时候，我们需要看一下webpack打包完成后，到底打包了什么东西， 这时候就需要用到这个模块分析工具了 webpack-bundle-analyzer 安装依赖 12npm install --save-dev webpack-bundle-analyzer复制代码 修改webpack-prod.js配置，在 plugins属性中新增一个插件 在开发环境中，我们是没必要进行模块打包分析的，所以我们将插件配置在了生产环境的配置项中 运行打包命令 12npm run build复制代码 执行成功后会自动打开这个页面 7. 集成 VueRouter,Vuex 首先是安装相关依赖 12npm install vue-router vuex --save复制代码 7.1 集成 Vue-Router 新增视图组件 在 src 目录下新增两个视图组件 src/views/Home.vue 和 src/views/About.vue 1234567891011121314151617181920// src/views/Home.vue&lt;template&gt; &lt;div class=&quot;Home&quot;&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;Home&#x27;, data() &#123; return &#123;&#125;; &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;复制代码 About.vue 内容跟 Home.vue 差不多，将里面的 Home 换成 About 就OK了 新增路由配置文件 在 src 目录下新增一个 router/index.js 文件 123456789101112131415161718192021222324// src/router/index.jsimport Vue from &#x27;vue&#x27;import VueRouter from &quot;vue-router&quot;;import Home from &#x27;../views/Home&#x27;;import About from &#x27;../views/About&#x27;;Vue.use(VueRouter)export default new VueRouter(&#123; mode: &#x27;hash&#x27;, routes: [ &#123; path: &#x27;/Home&#x27;, component: Home &#125;, &#123; path: &#x27;/About&#x27;, component: About &#125;, &#123; path: &#x27;*&#x27;, redirect: &#x27;/Home&#x27; &#125; ]&#125;)复制代码 修改 main.js 文件 12345678910// main.jsimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;new Vue(&#123; router, render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;)复制代码 修改 App.vue 组件 12345678910111213141516171819202122232425262728293031323334// App.vue// 在 template 中添加// src/App.vue&lt;template&gt; &lt;div class=&quot;App&quot;&gt; Hello World &lt;/div&gt; &lt;div&gt; // router-link 组件 用来导航到哪个路由 &lt;router-link to=&quot;/Home&quot;&gt;go Home&lt;/router-link&gt; &lt;router-link to=&quot;/About&quot;&gt;go About&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; // 用于展示匹配到的路由视图组件 &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, data() &#123; return &#123;&#125;; &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.App &#123; color: skyblue;&#125;&lt;/style&gt;复制代码 运行 npm run serve 命令，如没配置错误，是可以看到点击不同的路由，会切换到不同的路由视图 7.2 配置路由懒加载在没配置路由懒加载的情况下，我们的路由组件在打包的时候，都会打包到同一个js文件去，当我们的视图组件越来越多的时候，就会导致这个 js 文件越来越大。然后就会导致请求这个文件的时间变长，最终影响用户体验 安装依赖 12npm install @babel/plugin-syntax-dynamic-import --save-dev复制代码 修改babel.config.js 123456789101112131415module.exports = &#123; presets: [ [ &quot;@babel/preset-env&quot;, &#123; useBuiltIns: &quot;usage&quot; &#125; ] ], plugins: [ // 添加这个 &#x27;@babel/plugin-syntax-dynamic-import&#x27; ]&#125;复制代码 修改 router/index.js 路由配置文件 1234567891011121314151617181920212223import Vue from &#x27;vue&#x27;import VueRouter from &quot;vue-router&quot;;Vue.use(VueRouter)export default new VueRouter(&#123; mode: &#x27;hash&#x27;, routes: [ &#123; path: &#x27;/Home&#x27;, component: () =&gt; import(/* webpackChunkName: &quot;Home&quot; */ &#x27;../views/Home.vue&#x27;) // component: Home &#125;, &#123; path: &#x27;/About&#x27;, component: () =&gt; import(/* webpackChunkName: &quot;About&quot; */ &#x27;../views/About.vue&#x27;) // component: About &#125;, &#123; path: &#x27;*&#x27;, redirect: &#x27;/Home&#x27; &#125; ]&#125;)复制代码 运行命令 npm run build 查看是否生成了 Home...js 文件 和 About...js 文件 7.3 集成 Vuex 在 src 目录下新建一个 store/index.js 文件 1234567891011121314151617181920212223242526272829// store/index.jsimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)const state = &#123; counter: 0&#125;const actions = &#123; add: (&#123;commit&#125;) =&gt; &#123; return commit(&#x27;add&#x27;) &#125;&#125;const mutations = &#123; add: (state) =&gt; &#123; state.counter++ &#125;&#125;const getters = &#123; getCounter (state) &#123; return state.counter &#125;&#125;export default new Vuex.Store(&#123; state, actions, mutations, getters&#125;)复制代码 修改 main.js 文件 导入 vuex 1234567891011// main.jsimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27; // ++new Vue(&#123; router, store, // ++ render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;)复制代码 修改 App.vue ，查看 vuex 配置效果 123456789101112131415161718192021222324252627282930313233343536373839// App.vue&lt;template&gt; &lt;div class=&quot;App&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/Home&quot;&gt;go Home&lt;/router-link&gt; &lt;router-link to=&quot;/About&quot;&gt;go About&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;&#123;&#123;getCounter&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;add&quot;&gt;add&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapActions, mapGetters &#125; from &#x27;vuex&#x27;export default &#123; name: &#x27;App&#x27;, data() &#123; return &#123;&#125;; &#125;, computed: &#123; ...mapGetters([&#x27;getCounter&#x27;]) &#125;, methods: &#123; ...mapActions([&#x27;add&#x27;]) &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.App &#123; text-align: center; color: skyblue; font-size: 28px;&#125;&lt;/style&gt;复制代码 运行命令 npm run serve 当点击按钮的时候，可以看到我们的getCounter一直在增加 8 总结到目前为止，我们已经成功的自己搭建了一个 vue 开发环境，不过还是有一些功能欠缺的，有兴趣的小伙伴可以交流交流。在搭建过程中，还是会踩很多坑的。 如果还不熟悉 webpack 的话，建议自己搭建一次。可以让自己能深入的理解 vue-cli 替我们做了什么 作者：lentoo链接：https://juejin.cn/post/6844903833160646663来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[]},{"title":"vue生命周期","slug":"Vue生命周期","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2021/11/25/Vue生命周期/","link":"","permalink":"https://ysrandhw.github.io/2021/11/25/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"1、beforeCreate 在实例初始化之后，数据观测和event/watcher时间配置之前被调用。 2、created 实例已经创建完成之后被调用。在这一步，实例已经完成以下的配置：数据观测，属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，$el属性目前不可见。 3、beforeMount 在挂载开始之前被调用：相关的render函数首次被调用。 该钩子在服务器端渲染期间不被调用。 4、mounted el被新创建的 vm.$el替换，并挂在到实例上去之后调用该钩子函数。如果root实例挂载了一个文档内元素，当mounted被调用时vm.$el也在文档内。该钩子在服务端渲染期间不被调用。 5、beforeUpdate 数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。 你可以在这个钩子中进一步第更改状态，这不会触发附加的重渲染过程。 该钩子在服务端渲染期间不被调用。 6、updated 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。 当这个钩子被调用时，组件DOM已经更新，所以你现在可以执行依赖于DOM的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务端渲染期间不被调用。 7、activated keep-alive组件激活时调用。 该钩子在服务器端渲染期间不被调用。 8、deactivated keep-alive组件停用时调用。 该钩子在服务端渲染期间不被调用。 9、beforeDestroy 【类似于React生命周期的componentWillUnmount】 实例销毁之间调用。在这一步，实例仍然完全可用。 该钩子在服务端渲染期间不被调用。 10、destroyed Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 将路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件： 1- beforeRouteLeave:路由组件的组件离开路由前钩子，可取消路由离开。 2- beforeEach: 路由全局前置守卫，可用于登录验证、全局路由loading等。 3- beforeEnter: 路由独享守卫 4- beforeRouteEnter: 路由组件的组件进入路由前钩子。 5- beforeResolve:路由全局解析守卫 6- afterEach:路由全局后置钩子 7- beforeCreate:组件生命周期，不能访问this。 8- created:组件生命周期，可以访问this，不能访问dom。 9- beforeMount:组件生命周期 10- deactivated: 离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。 11- mounted:访问/操作dom。 12- activated:进入缓存组件，进入a的嵌套子组件(如果有的话)。 13- 执行beforeRouteEnter回调函数next。 Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。 每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。 实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的dom，一般不做操作 挂载数据，绑定事件等等，然后执行created函数，这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行beforeMount钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 接下来开始render，渲染出真实dom，然后执行mounted钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情… 当组件或实例的数据更改之后，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿 当更新完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom 当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等 组件的数据绑定、监听…去掉后只剩下dom空壳，这个时候，执行destroyed，在这里做善后工作也可以。","categories":[],"tags":[]},{"title":"","slug":"Typora添加右键新建快捷方式","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/11/15/Typora添加右键新建快捷方式/","link":"","permalink":"https://ysrandhw.github.io/2021/11/15/Typora%E6%B7%BB%E5%8A%A0%E5%8F%B3%E9%94%AE%E6%96%B0%E5%BB%BA%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/","excerpt":"","text":"window环境下 1，win+r 输入 regedit 打开注册表编辑器 找到HKEY_CLASSES_ROOT目录下的 .md 项，选择OpenWithProgids 新增值为 Typora.md 3.找到HKEY_CLASSES_ROOT目录下的 .md 项，选择选择新建项 ShellNew，选择新建的项 ShellNew 新增 字符串值 ，数值名称 NullFile，数值数据 为空不填写 4.鼠标右键，选择新建后则会多出 Markdowm File 选择","categories":[],"tags":[]},{"title":"vue性能优化","slug":"我的博客文章","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2021/11/14/我的博客文章/","link":"","permalink":"https://ysrandhw.github.io/2021/11/14/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"123456789101112组件懒加载 const Test = ()=&gt; import(&#x27;./Test.vue&#x27;)keep-alive 组件缓存 active deactive include exclude图片懒加载 v-lazy，需要在视图中展示的时候才显示数据冻结 Object.freeze（）， computed中 使用data数据 使用副本。v-for v-if 不能同时使用，computedv-if v-show长列表性能优化，虚拟滚动 vue-virtual-scroller,显示范围内的条目展示，需要的时候在加载更能多cpu换内存资源事件销毁，订阅，定时器，事件监听 beforeDestory（）&#123;&#125;第三方插件按需引入无状态的组件标记为函数式组件， &lt;template function&gt;子组件分割，比如耗时任务，动态内动 变化，自己管理自己，否则整个页面都会渲染、ssr：服务端渲染，seo，首屏获取速度","categories":[],"tags":[]},{"title":"博客测试123","slug":"hello-world","date":"un44fin44","updated":"un11fin11","comments":true,"path":"2021/07/29/hello-world/","link":"","permalink":"https://ysrandhw.github.io/2021/07/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}